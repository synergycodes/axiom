import fs from 'node:fs';
import path from 'node:path';
import type { PluginCreator } from 'postcss';

const outputDir = path.resolve(__dirname, '../../static/css');
const stylesFile = path.join(outputDir, 'shadow-dom-styles.css');
const cacheFile = path.join(outputDir, 'shadow-dom-styles.cache.json');

type ShadowDomCSSOptions = {
  filesToExtractPatterns: string[];
};

let isFirstPluginCall = true;

const generatedMissingPathsAndFilesIfNeeded = () => {
  // It's a gitignored dir and it is generated by the script
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir);
  }

  if (!fs.existsSync(stylesFile)) {
    fs.writeFileSync(
      stylesFile,
      '/* Mocked file run: pnpm clear before running server to regenerate */',
      'utf8',
    );
  }
};

const createStylesCollector = () => {
  let collectedStyles = '';
  const collectedPaths: string[] = [];

  return (filePath: string, { shouldLogAction = true } = {}) => {
    if (shouldLogAction) {
      console.log(
        ` ðŸŒ˜ ShadowDomCSS saves: ${filePath.replace(path.resolve(__dirname, '../../../..'), '')}`,
      );
    }

    const fileContent = fs.existsSync(filePath)
      ? fs.readFileSync(filePath, 'utf8')
      : '';

    if (fileContent) {
      collectedPaths.push(filePath.replaceAll('\\', '/'));
      collectedStyles = `${collectedStyles} ${fileContent}`;

      fs.writeFileSync(stylesFile, collectedStyles, 'utf8');
      fs.writeFileSync(
        cacheFile,
        JSON.stringify(collectedPaths, null, '\t'),
        'utf8',
      );
    }
  };
};

const regenerateStylesFromCacheIfPossible = () => {
  if (!fs.existsSync(cacheFile)) {
    return;
  }

  const cachedPaths = JSON.parse(
    fs.readFileSync(cacheFile, 'utf8'),
  ) as unknown as string[];

  if (cachedPaths.length > 0) {
    const collectStylesFromFile = createStylesCollector();

    for (const path of cachedPaths) {
      if (!fs.existsSync(path)) {
        console.log('   - The cache file has changed (dependencies were updated). Please run: pnpm website clear, and try again.');

        continue;
      }

      collectStylesFromFile(path, { shouldLogAction: false });
    }
  }
};

const ShadowDomCSS: PluginCreator<ShadowDomCSSOptions> = ({
  filesToExtractPatterns,
}) => {
  generatedMissingPathsAndFilesIfNeeded();

  if (isFirstPluginCall) {
    console.log('');
    console.log(' ðŸŒ˜ ShadowDomCSS is active.');
    console.log('   - To force a refresh of styles, run: pnpm website clear');

    isFirstPluginCall = false;

    regenerateStylesFromCacheIfPossible();
  }

  const collectStylesFromFile = createStylesCollector();

  return {
    postcssPlugin: 'shadow-dom-css',
    Once(root) {
      const inputFile = root.source?.input.file || '';

      const shouldExtract = filesToExtractPatterns.some((namePattern) =>
        inputFile.replaceAll('\\', '/').includes(namePattern),
      );

      if (shouldExtract) {
        collectStylesFromFile(root.source.input.file);
      }
    },
  };
};
ShadowDomCSS.postcss = true;

export default function () {
  return {
    name: 'shadow-dom-css-postcss',
    configurePostCss(postcssOptions) {
      postcssOptions.plugins.push(
        ShadowDomCSS({ filesToExtractPatterns: ['axiom/packages/ui'] }),
      );

      return postcssOptions;
    },
  };
}
